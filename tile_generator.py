#!/usr/bin/env python3

import png
import sys

TILE_W, TILE_H = 6, 8

# TODO: DON'T KEEP FONT IN RAM, USE LPM TO LOAD IT

# Note: also, only '_' actually uses a pixel on the far left in any of its rows; we might be able to
# cut down to 5-wide characters that always emit a background pixel on the far left

HEADER = """
;;; ============================================================================
;;; This is a code tile font file generated by tile_generator.py from:
;;;     {}
;;;
;;; It is intended for usage with video mode 96.

#include "../common.def.h"
"""[1:]

TILE_ROW_ASM = "\tTILE_ROW\t{}\t{} {} {} {} {} {}\t; {}\n"

def load_png(filepath):
    reader = png.Reader(filepath)
    w, h, image, m = reader.read()
    ret = list(image)
    return w, h, ret, m

if __name__ == '__main__':
    if len(sys.argv) != 3:
        print("Usage: tile_generator.py FILE.PNG OUTPUT_DIR")
        exit(1)

    FILEPATH = sys.argv[1]
    if not FILEPATH.endswith('.png'):
        print("Not running on non-PNG file '{}'".format(FILEPATH))
        exit(1)

    OUTPUT_DIR = sys.argv[2]
    if not OUTPUT_DIR.endswith('/'):
        OUTPUT_DIR += '/'

    try:
        FILENAME = FILEPATH[FILEPATH.rindex('/')+1:]
    except ValueError:
        # substring not found
        FILENAME = FILEPATH

    OUTPUT = OUTPUT_DIR + FILENAME[0:-4] + ".s"
        
    PNG_W_PX, PNG_H_PX, pixels, metadata = load_png(FILEPATH)
    W, H = int(PNG_W_PX/TILE_W), int(PNG_H_PX/TILE_H) # width, height of our image, in tiles

    tiles = []
    for tile_row in range(H):
        for tile_col in range(W):
            irow, icol = tile_row*TILE_H, tile_col*TILE_W
            tile = [foo[icol:icol+TILE_W] for foo in pixels[irow:irow+TILE_H]]
            tile = [''.join('1' if x else '0' for x in row) for row in tile]
            if tile not in tiles:
                tiles.append(tile)

    unique_rows = set()
    for tile in tiles:
        for row in tile:
            unique_rows.add(row)
    unique_rows = sorted(unique_rows)

    # for rowi in range(len(unique_rows)):
    #     print("{}:\t{}".format(rowi, unique_rows[rowi]))
    
    with open(OUTPUT, 'w') as f:
        f.write(HEADER.format(FILEPATH))

        # emit the tile table
        f.write("\n\t.section .data\n")
        f.write("\t.global m96_font\n")
        f.write("\nm96_font:")
        tileno = 0
        for tile in tiles:
            rowno = 0
            f.write("\n\t;; TILE {}\n".format(tileno))
            for row in tile:
                f.write("\t.byte\t{}\t; {}\n".format(unique_rows.index(row), row))
                rowno += 1
            tileno += 1

        # emit the actual code tiles
        f.write("\n")
        f.write("\t.section .text\n")
        f.write("\t.global m96_rows\n")
        f.write("m96_rows:\n")

        for rowi in range(len(unique_rows)):
            rargs = ['R_FG' if x == '1' else 'R_BG' for x in unique_rows[rowi]]
            f.write(TILE_ROW_ASM.format(rowi, *rargs, unique_rows[rowi]))
