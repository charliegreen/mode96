#!/usr/bin/env python3

import png
import sys

TILE_W, TILE_H = 6, 8

# TODO: DON'T KEEP FONT IN RAM, USE LPM TO LOAD IT

# Note: also, only '_' actually uses a pixel on the far left in any of its rows; we might be able to
# cut down to 5-wide characters that always emit a background pixel on the far left

HEADER = """
;;; ============================================================================
;;; This is a code tile font file generated by tile_generator.py from:
;;;     {}
;;;
;;; It is intended for usage with video mode 96.

#include "../videoMode.def.h"
"""[1:]

TILE_ROW_ASM = """
	out	VIDEO_PORT, {0}
	
	;; ---------------------------------------- read VRAM
	sbrs	r6, 0
	rjmp	1f

	;; color, then text
	ld	r20, Y+
	out	VIDEO_PORT, {1}
	ld	r4, Y+
	rjmp	2f
1:
	ld	r4, Y+
	out	VIDEO_PORT, {1}
	ld	r20, Y
	swap	r20
2:
	out	VIDEO_PORT, {2}
	andi	r20, 0x0F

	;; ---------------------------------------- loading colors
	lsl	r20

	ldi	XL, lo8(m96_palette)
	add	XL, r20

	out	VIDEO_PORT, {3}

	;; ---------------------------------------- loading next tile
	;; r4 is now an index into m96_font

	ldi	ZL, lo8(m96_font)
	ldi	ZH, hi8(m96_font)
	add	ZL, r25		; tile row counter
	ldi	r16, 8
	mul	r4, r16
	add	ZL, r0
	adc	ZH, r1
	ld	r4, Z

	mul	r4, r5
	add	r0, r22
	out	VIDEO_PORT, {4}
	adc	r1, r23
	movw	r30, r0

	dec	r6		; we can move this up here because out and ld don't modify SREG

	out	VIDEO_PORT, {5}
	
	;; ---------------------------------------- load colors
	ld	r19, X+
	ld	r18, X
	
	breq	.+2
	ijmp
	ret
"""

def load_png(filepath):
    reader = png.Reader(filepath)
    w, h, image, m = reader.read()
    ret = list(image)
    return w, h, ret, m

if __name__ == '__main__':
    if len(sys.argv) != 3:
        print("Usage: tile_generator.py FILE.PNG OUTPUT_DIR")
        exit(1)

    FILEPATH = sys.argv[1]
    if not FILEPATH.endswith('.png'):
        print("Not running on non-PNG file '{}'".format(FILEPATH))
        exit(1)

    OUTPUT_DIR = sys.argv[2]
    if not OUTPUT_DIR.endswith('/'):
        OUTPUT_DIR += '/'

    try:
        FILENAME = FILEPATH[FILEPATH.rindex('/')+1:]
    except ValueError:
        # substring not found
        FILENAME = FILEPATH

    OUTPUT = OUTPUT_DIR + FILENAME[0:-4] + ".s"
        
    PNG_W_PX, PNG_H_PX, pixels, metadata = load_png(FILEPATH)
    W, H = int(PNG_W_PX/TILE_W), int(PNG_H_PX/TILE_H) # width, height of our image, in tiles

    tiles = []
    for tile_row in range(H):
        for tile_col in range(W):
            irow, icol = tile_row*TILE_H, tile_col*TILE_W
            tile = [foo[icol:icol+TILE_W] for foo in pixels[irow:irow+TILE_H]]
            tile = [''.join('1' if x else '0' for x in row) for row in tile]
            if tile not in tiles:
                tiles.append(tile)

    unique_rows = set()
    for tile in tiles:
        for row in tile:
            unique_rows.add(row)
    unique_rows = sorted(unique_rows)

    # for rowi in range(len(unique_rows)):
    #     print("{}:\t{}".format(rowi, unique_rows[rowi]))
    
    with open(OUTPUT, 'w') as f:
        f.write(HEADER.format(FILEPATH))

        # emit the tile table
        f.write("\n\t.section .data\n")
        f.write("\t.global m96_font\n")
        f.write("\nm96_font:")
        tileno = 0
        for tile in tiles:
            rowno = 0
            f.write("\n\t;; TILE {}\n".format(tileno))
            for row in tile:
                f.write("\t.byte\t{}\t; {}\n".format(unique_rows.index(row), row))
                rowno += 1
            tileno += 1

        # emit the actual code tiles
        f.write("\n")
        f.write("\t.section .text\n")
        f.write("\t.global m96_rows\n")
        f.write("m96_rows:")

        for rowi in range(len(unique_rows)):
            f.write("\n;;;---------------------------------------- tile row {}: {}\n".format(
                rowi, unique_rows[rowi]))
            f.write("_tilerow_{}:".format(rowi))
            f.write(TILE_ROW_ASM.format(*['r18' if x == '1' else 'r19' for x in unique_rows[rowi]]))
